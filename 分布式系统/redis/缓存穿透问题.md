#### 第一种情况：恶意攻击

专门构建一些缓存和数据库中均没有的数据，打到DB。

解决方案：

\- 缓存空值

\- 采用一定的规则定义key，不符合规则的直接过滤

\- 布隆过滤器

#### 第二种情况：突然一大波冷数据

无法命中缓存，直接落到DB

解决方案：

- 使用冷数据构建布隆过滤器直接过滤
- 预热
- 冷热分离

#### 第三种情况：一大波缓存同时失效   (缓存雪崩)

因为过期时间设置不合理，有一波缓存同时失效。

解决方案：

- 缓存过期时间加上随机值。

- 缓存续期 --参考redisson的watchDog

#### 第四种情况：热点数据失效   （缓存并发）

某一个热点数据过期，同时有一波重复请求过来，比如秒杀场景

解决方案：

- 分布式锁或者本地锁，比较暴力，只是把并发压力前置到了锁身上，不推荐

- 排队

- 自动续期，起一个定时任务定时对热点数据进行续期，参考redisson的watchdog机制

- 采用响应分发的机制，参考netty响应分发，根据请求路径或者商品ID进行hash分桶，key是请求ID，value是一个future，重复请求会命中同一个hash槽，只会有一个请求去后台查缓存或者DB。其余请求均在这个future上等待。

这还会起到一个好处：后续的请求的响应是呈一个衰减的形势的，越晚到该future上的请求rt越低，所以最终它的平均rt会减半。