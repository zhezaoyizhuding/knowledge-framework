<img src="https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/Mysql.png" alt="Mysql" style="zoom: 33%;" />

![image-20220419233616850](https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20220419233616850.png)

## Mysql内部结构

<img src="https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005100751702.png" alt="image-20221005100751702" style="zoom:50%;" />

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 

**Server层** 

主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 

**Store层**

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说如果我们在create table时不指定表的存储引擎类型,默认会给你设置存储引擎为InnoDB。

## 一条SQL语句是如何执行的

#### 查询

如上图，经过多个组件，直接从内存里读取

#### 更新

<img src="https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005103433370.png" alt="image-20221005103433370" style="zoom:50%;" />

与查询相比，多了个写redolog。

## 联合索引结构

![image-20221012165711655](https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221012165711655.png)

## 事务

事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。

- 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 

- 一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。 

- 隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 

- 持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

#### 隔离级别

![image-20221005103735224](https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005103735224.png) 

## 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

**锁分类** 

- 从性能上分为乐观锁(用版本对比来实现)和悲观锁 

- 从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁) 

  - 读锁（共享锁，S锁(**S**hared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响 

  - 写锁（排它锁，X锁(e**X**clusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁 

- 从对数据操作的粒度分，分为表锁和行锁 

#### 表锁

每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。

#### 行锁

每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。InnoDB支持行锁，MYISAM不支持。

#### 间隙锁

mysql中用来解决幻读的锁机制，它并不和其他的间隙锁冲突，即一个区间间隙可以加多个间隙锁，彼此之间不冲突。间隙锁只和“在这个间隙中间插入数据”这个操作冲突。

#### 临键锁

临键锁=行锁+间隙锁，是msyql中基本的锁单位。即mysql中加锁不是单独加行锁与间隙锁，而是直接加上临键锁，然后再根据sql的情况退化成行锁或者间隙锁。临键锁是前开后闭的（后闭即是行锁）。

#### 锁优化建议

- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 

- 合理设计索引，尽量缩小锁的范围 

- 尽可能减少检索条件范围，避免间隙锁 

- 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 

- 尽可能低级别事务隔离

## MVCC多版本并发控制

MVCC = ReadView + undolog。MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。

#### undolog

undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链

![image-20221005110237537](https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005110237537.png)

在**可重复读隔离级别**，当事务开启，执行任何查询sql时会生成当前事务的**一致性视图read-view，**该视图在事务结束之前都不会变化(**如果是读已提交隔离级别在每次执行查询sql时都会重新生成read-view**)，这个视图由执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。

<img src="https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005110403722.png" alt="image-20221005110403722" style="zoom:50%;" />

**版本链比对规则：** 

- 如果 row 的 trx_id 落在绿色部分( trx_id<min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； 

- 如果 row 的 trx_id 落在红色部分( trx_id>max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若row 的 trx_id 就是当前自己的事务是可见的）

- 如果 row 的 trx_id 落在黄色部分(min_id <=trx_id<= max_id)，那就包括两种情况 

  - 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)； 

  - 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。

对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据。

**注意：**begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句，事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的（有三种策略选择）。

## BufferPool缓存机制

![image-20221005111047535](https://yusheng-picgo.oss-cn-beijing.aliyuncs.com/picgo/image-20221005111047535.png)

图中如果内存数据没有命中，则会从磁盘加载数据。如果此时Buffer Pool内存不足，则会刷脏页。这算是比较耗时的一条路劲，通常会照成msyql的抖动。

**为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？** 

因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。Mysql这套机制看起来复杂，但它可以保证每个更新请求都是**更新内存BufferPool**，然后**顺序写日志文件**，同时还能保证各种异常情况下的数据一致性。更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干的读写请求。
