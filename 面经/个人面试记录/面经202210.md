## XTransfer

- 滑动窗口与其他限流算法的优劣

- 一个二维数组，按行读与按列读，哪个更快？为什么？ -- cpu三级缓存，局部读取

  https://zhuanlan.zhihu.com/p/461548456

- Leetcode92

## ZOOm

- java线程池的几种拒绝策略并不友好，有时我们任务比较重要，不想丢失，该怎么做？

自定义拒绝策略，将任务放在MQ里，然后线程池从MQ里消费，再重新执行

- zookeeper watch事件丢失问题

因为原生 zookeeper的watch机制只会触发一次，要想再次监听节点的变化，需要重新注册监听。而通用的客户端curator虽然实现了获取监听再重新注册的逻辑。但是这是两个操作，中间会有延迟。然后如果在这个延迟期间如果有节点变更，那么这个变更事件就会丢失。

- jvm中堆是共享的，那么如果多个线程同时去开辟一个地址空间，这个并发问题是如何处理的？

一、CAS + 失败重试
CAS是一种乐观锁的实现方式，每次不加锁假设没有冲突的去完成某项操作，如果因为冲突导致操作失败就重试，直到成功为止。详见博客，传送地址：Java并发编程之 无锁（CAS）

二、TLAB
TLAB是在Java堆空间的伊甸园划分出来的针对每个线程的内存空间，专门在该区域为该线程创建的对象分配内存。

它的主要目的是在并发环境下进行内存分配的时候，减少线程之间对于内存空间的竞争，加速内存分配的速度。

TLAB本质上还是在Java堆中的，所以在TLAB区域的对象，也可以被其他线程访问。

如果没有使用TLAB，多个并发执行的线程创建对象，分配内存的时候，有可能在Java堆中的同一个位置申请，这就需要对这部分内存空间进行加锁或者采用CAS等操作保证线程安全，即保证该区域只分配给一个线程。

使用了TLAB之后，JVM会针对每个线程在堆内存中预留一个内存区域，在预留这个操作发生的时候，需要进行加锁或者采用CAS等操作进行保护，避免多个线程预留同一个区域。一旦确定了某个区域分配给某个线程，之后该线程需要分配内存的时候，会优先在这片区域申请。这个区域对于该线程分配内存这个操作而言是线程私有的，因此在分配的时候不用进行加锁等操作，从而既保护了线程安全又提升了分配速度。

注意： 当该线程创建的对象大于TLAB中的剩余内存或者TLAB的内存已用尽时，再采用CAS + 失败重试的方式分配内存。

- 直接内存如何回收？

full gc会调用Cleaner回收堆外内存，Cleaner是一个虚引用。在java的DirectByteBuffer被删除时会用Cleaner去记录他的虚引用。
